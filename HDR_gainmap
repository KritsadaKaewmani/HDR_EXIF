import numpy as np
import cv2
import subprocess
import os

def pq_eotf(image_pq):
    """
    Converts Rec.2100 PQ (0-1 range) to Linear Light (0-10000 nits range).
    Standard SMPTE ST 2084 EOTF.
    """
    m1 = 2610.0 / 16384.0
    m2 = 2523.0 / 4096.0
    c1 = 3424.0 / 4096.0
    c2 = 2413.0 / 4096.0
    c3 = 2392.0 / 4096.0

    # Avoid division by zero/complex numbers
    image_pq = np.maximum(image_pq, 0.0)
    
    num = np.maximum(image_pq**(1.0/m2) - c1, 0.0)
    den = c2 - c3 * (image_pq**(1.0/m2))
    
    linear = (num / den) ** (1.0/m1)
    return linear * 10000.0  # Scale to absolute nits

def linear_to_srgb(linear_image):
    """
    Simple tone mapping and gamma correction for the SDR Base Image.
    Adjust 'exposure' to control SDR brightness.
    """
    # 1. Simple Tone Mapping (Reinhard or similar) to bring 1000 nits down to 0-1
    # Adjust this scalar to set the "SDR White Point" (e.g., 203 nits maps to ~1.0)
    sdr_white_nits = 203.0 
    mapped = linear_image / sdr_white_nits
    mapped = mapped / (1 + mapped) # Reinhard tonemap
    
    # 2. Gamma Correct (Standard sRGB approx)
    srgb = np.where(mapped <= 0.0031308, 
                    12.92 * mapped, 
                    1.055 * (mapped ** (1.0/2.4)) - 0.055)
    return np.clip(srgb, 0, 1)

def create_gain_map(hdr_linear, sdr_linear, max_headroom=None):
    """
    Calculates the Gain Map.
    Gain = (HDR / SDR). 
    Apple Gain Maps are typically stored as a sqrt or log encoded image.
    Here we create a linear ratio map suitable for the auxiliary image.
    """
    # Avoid division by zero
    sdr_safe = np.maximum(sdr_linear, 1e-6)
    gain = hdr_linear / sdr_safe
    
    if max_headroom is None:
        max_headroom = np.max(gain)
        
    # Log-encode or Sqrt-encode is common for storage efficiency in 8-bit
    # For this example, we normalize to 0-1 based on headroom
    # Map 1.0 -> 0 (No gain) to Headroom -> 1.0 (Max gain)
    
    # Simple linear normalization for the gain map image
    # Note: Real implementations often use specific curves. 
    # This is a functional approximation.
    gain_map_norm = (np.log2(gain + 1e-6)) / np.log2(max_headroom)
    
    return np.clip(gain_map_norm, 0, 1), max_headroom

# --- Main Processing ---

# 1. Load HDR Image (16-bit TIF)
input_tif = "input_hdr.tif"
# Read as 16-bit unsigned (-1 flag in cv2)
img_uq = cv2.imread(input_tif, cv2.IMREAD_UNCHANGED)
# Convert to 0-1 Float PQ
img_pq = img_uq.astype(np.float32) / 65535.0

# 2. Linearize PQ to Nits
print("Converting PQ to Linear...")
img_linear = pq_eotf(img_pq)

# 3. Create SDR Base Image
print("Creating SDR Base Image...")
img_sdr_linear = img_linear.copy() # Simplification for example
img_sdr_srgb = linear_to_srgb(img_sdr_linear)
img_sdr_uint8 = (img_sdr_srgb * 255).astype(np.uint8)

# 4. Create Gain Map
print("Creating Gain Map...")
# We use Luminance (Y) for gain map calculation to save space
# Y = 0.2126 R + 0.7152 G + 0.0722 B
lum_hdr = 0.2126 * img_linear[:,:,2] + 0.7152 * img_linear[:,:,1] + 0.0722 * img_linear[:,:,0]
lum_sdr = 0.2126 * img_sdr_linear[:,:,2] + 0.7152 * img_sdr_linear[:,:,1] + 0.0722 * img_sdr_linear[:,:,0]

gain_map, headroom = create_gain_map(lum_hdr, lum_sdr)
gain_map_uint8 = (gain_map * 255).astype(np.uint8)

print(f"Calculated Max Headroom: {headroom:.2f}")

# 5. Save Intermediate Files
cv2.imwrite("temp_sdr.jpg", img_sdr_uint8, [cv2.IMWRITE_JPEG_QUALITY, 90])
# Gain map is usually smaller (1/2 or 1/4 resolution)
h, w = gain_map_uint8.shape
gain_map_resized = cv2.resize(gain_map_uint8, (w // 2, h // 2))
cv2.imwrite("temp_gain.jpg", gain_map_resized, [cv2.IMWRITE_JPEG_QUALITY, 85])

# 6. Call heif-enc to stitch
# This matches the Apple Gain Map URN
output_heic = "output_gainmap.heic"
urn = "urn:com:apple:photo:2020:aux:hdrgainmap"

cmd = [
    "heif-enc",
    "-o", output_heic,
    "temp_sdr.jpg",
    f"--aux-image={urn},temp_gain.jpg"
]

print(f"Running command: {' '.join(cmd)}")
try:
    subprocess.run(cmd, check=True)
    print(f"Success! Created {output_heic}")
    # Optional: Inject Metadata via ExifTool if needed for 'Headroom' tag
    # ExifTool command: exiftool -Apple:HDRHeadroom=headroom output.heic
except FileNotFoundError:
    print("Error: 'heif-enc' not found. Please install libheif.")
except subprocess.CalledProcessError as e:
    print(f"Error creating HEIC: {e}")

# Cleanup
if os.path.exists("temp_sdr.jpg"): os.remove("temp_sdr.jpg")
if os.path.exists("temp_gain.jpg"): os.remove("temp_gain.jpg")


# To ensure the gain map works perfectly on Apple Photos/Preview, 
# you should inject the specific headroom value into the metadata using exiftool 
# (which can also be called from Python):
# Calculate headroom in stops or ratio (e.g. 3.0)
subprocess.run(["exiftool", "-overwrite_original", "-Apple:HDRHeadroom=3.0", output_heic])